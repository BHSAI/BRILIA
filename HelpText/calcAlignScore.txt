calcAlignScore takes a logical MxN matrix returned from a sequence
comparison resuls (SeqA == SeqB) and calculates the alignment score per
each row using the following equation:
SUM( (consecutive matches)^2 ) + SUM( (consecutive mismatches)^2 )

  Score = calcAlignScore(MatchResults)

  Score = calcAlignScore(MatchResults,AllowedMiss)

  Score = calcAlignScore(MatchResults,AllowedMiss,GoodIdx)

  INPUT
    MatchResults: MxN logical matrix of match (1) and mismatch (0), OR a
      3xN char matrix with 2nd row having "|" as matches
    AllowedMiss: Integer number of allowed point misses allowed, from left
      to right, in order to elongate a consecutive match segment. Score
      for [1 0 1] is 1 with AllowedMiss = 0, and 4 if AllowedMiss = 1;
    GoodIdx: Empty or MxN logical matrix indiciating which nt matches
      should be counted towards the score. Used mainly if you don't want
      edges to be counted towards the scoring function. If GoodIdx is
      empty, score will be calculated based on location of first and last
      match.

  OUTPUT
    Score: Mx1 alignment scores

  EXAMPLES
    Case 1) 2 point mutations
      Seq1 = 'GGGGGG'
      Seq2 = 'GTGGTG'
      MatchResults = Seq1 == Seq2;
      Score1 = calcAlignScore(MatchResults,0)
          Score1 = 4
      Score2 = calcAlignScore(MatchResults,1)
          Score2 = 9
      Score3 = calcAlignScore(MatchResults,2)
          Score2 = 16

    Case 2) 1 consecutive double mutations (so must accept mismatch)
      Seq1 = 'GGGGGG'
      Seq2 = 'GGTTGG'
      MatchResults = Seq1 == Seq2;
      Score1 = calcAlignScore(MatchResults,0)
          Score1 = 4
      Score2 = calcAlignScore(MatchResults,2)
          Score2 = 4

    Case 3) Using GoodIdx input
      SeqA = 'ABCD'
      SeqB = 'CDFADSD';
      [Diag1, Diag2, GoodIdx] = makeDiagonalSeq(SeqA,SeqB)
      Scores = calcAlignScore(Diag1 == Diag2,GoodIdx)

  See also alignSeq, makeDiagonalSeq
